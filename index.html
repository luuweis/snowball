<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ‰‹åŠ¿æ§åˆ¶3Dç²’å­ç³»ç»Ÿ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; touch-action: none; user-select: none; -webkit-user-select: none; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        .input_video { display: none; }
        
        
        /* UI è¦†ç›–å±‚ */
        #ui-layer {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 10;
            color: white;
            pointer-events: none;
        }

        .controls-info {
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.1);
        }

        h1 { margin: 0 0 10px 0; font-size: 1.2rem; text-transform: uppercase; letter-spacing: 2px; }
        p { margin: 5px 0; font-size: 0.9rem; color: #aaa; }
        
        .key {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            font-weight: bold;
            color: #fff;
        }

        #fullscreen-btn {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 10px 20px;
            cursor: pointer;
            border-radius: 20px;
            transition: 0.3s;
            backdrop-filter: blur(5px);
            font-size: 14px;
            white-space: nowrap;
        }
        #dpad-container {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: none; /* é»˜è®¤éšè—ï¼Œä»…ç§»åŠ¨ç«¯æ˜¾ç¤º */
            width: 120px;
            height: 120px;
            pointer-events: none; /* å®¹å™¨ç©¿é€ï¼Œåªæœ‰æŒ‰é’®å“åº” */
        }
        .dpad-btn {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            color: white;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            backdrop-filter: blur(5px);
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }
        .dpad-btn:active { background: rgba(255, 255, 255, 0.4); }
        #dpad-up { top: 0; left: 40px; }
        #dpad-down { bottom: 0; left: 40px; }
        #dpad-left { top: 40px; left: 0; transform: rotate(-90deg); }
        #dpad-right { top: 40px; right: 0; transform: rotate(90deg); }
        .fade-transition {
            transition: opacity 0.5s ease-in-out;
            opacity: 1;
        }
        .fade-out {
            opacity: 0 !important;
            pointer-events: none !important;
        }

        /* Toast Notification */
        #toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            z-index: 200;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            font-size: 14px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.2);
        }
        #toast.show {
            opacity: 1;
        }

        
    </style>
    <!-- å¼•å…¥ Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- å¼•å…¥ Lil-GUI -->
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.17.0/dist/lil-gui.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
    <div id="canvas-container"></div>
    <video class="input_video" playsinline></video>
    <div id="dpad-container" class="fade-transition">
        <div class="dpad-btn" id="dpad-up">â–²</div>
        <div class="dpad-btn" id="dpad-left">â–²</div>
        <div class="dpad-btn" id="dpad-right">â–²</div>
        <div class="dpad-btn" id="dpad-down">â–¼</div>
    </div>
    <button id="fullscreen-btn" class="fade-transition">å…¨å±æ¨¡å¼</button>
    <div id="toast">æ¶ˆæ¯æç¤º</div>

    <div id="ui-layer" class="fade-transition">
        <div class="controls-info" id="controls-info-panel">
            <h1>ç²’å­ç³»ç»Ÿ</h1>
            <div id="desktop-instructions">
                <p>âŒ¨ <b>æ–¹å‘é”®:</b> æ—‹è½¬è§†è§’</p>
                <p>ğŸ–± <b>é¼ æ ‡:</b> ç‚¹å‡»é€‰æ‹©å¹¶æ‹–åŠ¨ç²’å­ç¾¤</p>
                <p>ğŸ¤š <b>å•æ‰‹æåˆ:</b> é€‰ä¸­å¹¶æ‹–åŠ¨æœ€è¿‘ç²’å­ç¾¤</p>
                <p>âœ‹ <b>åŒæ‰‹ç¼©æ”¾:</b> å¦ä¸€åªæ‰‹å¼ å¼€æ”¾å¤§ï¼Œæ¡æ‹³ç¼©å°</p>
                <p>ğŸ‘‹ <b>åŒæ‰‹æ—‹è½¬:</b> æåˆæ‰‹ä¿æŒï¼Œå¦ä¸€åªæ‰‹ç§»åŠ¨æ—‹è½¬</p>
            </div>
            <div id="mobile-instructions" style="display: none;">
                <p>ğŸ‘† <b>å•æŒ‡æ‹–æ‹½:</b> æ—‹è½¬è§†è§’</p>
                <p>ğŸ‘† <b>é•¿æŒ‰ç²’å­:</b> æ‰“å¼€è®¾ç½®é¢æ¿</p>
                <p>ğŸ¤ <b>åŒæŒ‡æ“ä½œ:</b> ç¼©æ”¾/æ—‹è½¬é€‰ä¸­ç²’å­ç¾¤</p>
                <p>ğŸ–– <b>ä¸‰æŒ‡æ“ä½œ:</b> å‚ç›´æ—‹è½¬é€‰ä¸­ç²’å­ç¾¤</p>
                <p>ğŸ‘† <b>ç‚¹å‡»ç²’å­:</b> é€‰ä¸­å¹¶æ‹–åŠ¨ç²’å­ç¾¤</p>
            </div>
            <p>âš™ <b>å‚æ•°è®¾ç½®:</b> å³ä¸‹è§’é¢æ¿è°ƒèŠ‚</p>
        </div>
    </div>

<script>
    /**
     * 1. åˆå§‹åŒ–åœºæ™¯å˜é‡
     */
    let scene, camera, renderer;
    let particleSystems = [];
    let gui;
    let raycaster = new THREE.Raycaster();
    raycaster.params.Points = { threshold: 0.5 };
    let mouse = new THREE.Vector2();
    let selectedSystem = null;
    let isDragging = false;
    let dragPlane = new THREE.Plane();
    let dragOffset = new THREE.Vector3();
    let initialPinchDistance = 0;
    let initialScale = 1;
    let lastPinchAngle = 0;
    let isPinching = false;
    let isThreeFinger = false;
    let lastSecondHandPos = new THREE.Vector2(); // è®°å½•ç¬¬äºŒåªæ‰‹ä¸Šä¸€å¸§çš„ä½ç½®
    let isTwoHandRotationActive = false;
    let pinchSession = { active: false, startWorld: new THREE.Vector3(), startGroupPos: new THREE.Vector3(), handIndex: -1 };
    let longPressTimer = null;
    const LONG_PRESS_DURATION = 800; // ms
    let uiHideTimer = null;
    const UI_HIDE_DELAY = 3000;
    let toastTimer = null;
    const gestureConfig = {
        pinchThreshold: 0.05,
        followLerp: 0.25,
        worldScaleX: 30,
        worldScaleY: 20,
        openScore: 0.18,
        fistScore: 0.10,
        scaleMin: 0.4,
        scaleMax: 2.5,
        scaleLerp: 0.25
    };
    const AVAILABLE_SHAPES = ['sphere','cube','cuboid','cylinder','torus','spiral','crescent','semicircle','lightning','cone','heart','star','text','ellipsoid','pyramid','capsule'];
    
    
    // æ‘„åƒæœºæ—‹è½¬å‚æ•°
    let camAngle = 0;
    let camHeight = 0;
    const CAM_RADIUS = 30;

    // é‡æ–°æ·»åŠ  lastThreeFingerY å®šä¹‰ï¼Œåˆšæ‰è¢«è¦†ç›–äº†
    let lastThreeFingerY = 0;
    function createTexture(type) {
        const canvas = document.createElement('canvas');
        canvas.width = 32;
        canvas.height = 32;
        const ctx = canvas.getContext('2d');
        const center = 16;
        
        ctx.clearRect(0,0,32,32);

        if (type === 'glow') {
            const grad = ctx.createRadialGradient(center, center, 0, center, center, 16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 32, 32);
        } else if (type === 'rain') {
            ctx.fillStyle = 'white';
            ctx.fillRect(14, 0, 4, 32);
        } else if (type === 'snow') {
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(16,0); ctx.lineTo(16,32);
            ctx.moveTo(0,16); ctx.lineTo(32,16);
            ctx.moveTo(4,4); ctx.lineTo(28,28);
            ctx.moveTo(28,4); ctx.lineTo(4,28);
            ctx.stroke();
        } else {
            // Default square
            ctx.fillStyle = 'white';
            ctx.fillRect(4,4,24,24);
        }

        const texture = new THREE.CanvasTexture(canvas);
        return texture;
    }

    /**
     * 2. ç²’å­ç¾¤ç±» (ParticleCloud)
     */
        class ParticleCloud {
            constructor(id, options = {}) {
            this.id = id;
            this.count = options.count || 2000;
            this.color = options.color || '#00ffff';
            this.size = options.size || 0.2;
            this.shapeType = options.shapeType || 'glow';
            this.spread = 10;
            
            // å‡ ä½•ä½“
            this.geometry = new THREE.BufferGeometry();
            this.positions = new Float32Array(this.count * 3);
            this.targetPositions = new Float32Array(this.count * 3);
            
            // åˆå§‹åŒ–éšæœºä½ç½® (çƒä½“)
            for(let i=0; i<this.count; i++) {
                this.setTargetSphere(i, this.spread);
                // åˆå§‹ä½ç½®è®¾ä¸ºç›®æ ‡ä½ç½®
                this.positions[i*3] = this.targetPositions[i*3];
                this.positions[i*3+1] = this.targetPositions[i*3+1];
                this.positions[i*3+2] = this.targetPositions[i*3+2];
            }

            this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
            this.geometry.computeBoundingSphere();

            // æè´¨
            this.material = new THREE.PointsMaterial({
                color: this.color,
                size: this.size,
                map: createTexture(this.shapeType),
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            this.mesh = new THREE.Points(this.geometry, this.material);
            scene.add(this.mesh);

            // çŠ¶æ€
            this.currentShape = options.currentShape || 'sphere';
            this.shapeChoices = ['sphere','cube','torus','spiral','cuboid','cylinder','crescent','semicircle','lightning','cone','heart','star','text','ellipsoid','pyramid','capsule'];
            this.shapeScale = options.shapeScale || 15;
            this.rotationSpeed = options.rotationSpeed || 0.002;
            
            // æ–‡å­—å½¢çŠ¶ç›¸å…³
            this.textString = options.textString || "AI";
            this.textPoints = [];
            this.generateTextPoints();

            if (options.scale && typeof options.scale === 'object') {
                const sx = options.scale.x ?? 1;
                const sy = options.scale.y ?? 1;
                const sz = options.scale.z ?? 1;
                this.mesh.scale.set(sx, sy, sz);
            }

            if (options.position && typeof options.position === 'object') {
                const px = options.position.x ?? 0;
                const py = options.position.y ?? 0;
                const pz = options.position.z ?? 0;
                this.mesh.position.set(px, py, pz);
            }
        }

        rand1(i, s=0) {
            const x = Math.sin(i * 12.9898 + s * 78.233) * 43758.5453;
            return x - Math.floor(x);
        }

        generateTextPoints() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const fontSize = 100;
            const font = `900 ${fontSize}px sans-serif`; // Boldest
            ctx.font = font;
            const text = this.textString;
            const metrics = ctx.measureText(text);
            const width = Math.ceil(metrics.width) || 100;
            const height = Math.ceil(fontSize * 1.5);
            
            canvas.width = width;
            canvas.height = height;
            
            ctx.font = font;
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, width / 2, height / 2);
            
            const imgData = ctx.getImageData(0, 0, width, height);
            const data = imgData.data;
            this.textPoints = [];
            
            // é‡‡æ ·æ­¥é•¿ï¼Œè¶Šå°è¶Šç²¾ç»†ä½†ç‚¹è¶Šå¤š
            const step = 2; 
            for (let y = 0; y < height; y += step) {
                for (let x = 0; x < width; x += step) {
                    const index = (y * width + x) * 4;
                    if (data[index + 3] > 128) {
                        // å½’ä¸€åŒ–åæ ‡ï¼Œä»¥é«˜åº¦ä¸ºåŸºå‡†
                        const nx = (x - width / 2) / height; 
                        const ny = -(y - height / 2) / height; 
                        this.textPoints.push({x: nx, y: ny});
                    }
                }
            }
        }

        setText(str) {
            if (this.textString === str) return;
            this.textString = str;
            this.generateTextPoints();
        }

        // è¾…åŠ©æ•°å­¦å‡½æ•°ï¼šè®¾ç½®ç¬¬iä¸ªç²’å­çš„ç›®æ ‡ä¸ºçƒä½“è¡¨é¢
        setTargetSphere(i, radius, offsetX=0, offsetY=0, offsetZ=0) {
            const phi = Math.acos(-1 + (2 * i) / this.count);
            const theta = Math.sqrt(this.count * Math.PI) * phi;
            this.targetPositions[i*3] = radius * Math.cos(theta) * Math.sin(phi) + offsetX;
            this.targetPositions[i*3+1] = radius * Math.sin(theta) * Math.sin(phi) + offsetY;
            this.targetPositions[i*3+2] = radius * Math.cos(phi) + offsetZ;
        }

        // è¾…åŠ©æ•°å­¦å‡½æ•°ï¼šè®¾ç½®ç¬¬iä¸ªç²’å­çš„ç›®æ ‡ä¸ºç«‹æ–¹ä½“
        setTargetCube(i, size, offsetX=0, offsetY=0, offsetZ=0) {
            const side = Math.cbrt(this.count); // ç®€å•ä¼°ç®—
            const x = (Math.random() - 0.5) * size + offsetX;
            const y = (Math.random() - 0.5) * size + offsetY;
            const z = (Math.random() - 0.5) * size + offsetZ;
            this.targetPositions[i*3] = x;
            this.targetPositions[i*3+1] = y;
            this.targetPositions[i*3+2] = z;
        }

        setTargetCubeSurface(i, size, offsetX=0, offsetY=0, offsetZ=0) {
            const half = size * 0.5;
            const face = i % 6;
            const u = (this.rand1(i, 1) - 0.5) * size;
            const v = (this.rand1(i, 2) - 0.5) * size;
            let x = 0, y = 0, z = 0;
            if (face === 0) { x = half; y = u; z = v; }
            else if (face === 1) { x = -half; y = u; z = v; }
            else if (face === 2) { y = half; x = u; z = v; }
            else if (face === 3) { y = -half; x = u; z = v; }
            else if (face === 4) { z = half; x = u; y = v; }
            else { z = -half; x = u; y = v; }
            this.targetPositions[i*3] = x + offsetX;
            this.targetPositions[i*3+1] = y + offsetY;
            this.targetPositions[i*3+2] = z + offsetZ;
        }

        setTargetTorus(i, R, r, offsetX=0, offsetY=0, offsetZ=0) {
            const u = (i / this.count) * Math.PI * 2;
            const v = (((i * 7) % this.count) / this.count) * Math.PI * 2;
            const x = (R + r * Math.cos(v)) * Math.cos(u) + offsetX;
            const y = r * Math.sin(v) + offsetY;
            const z = (R + r * Math.cos(v)) * Math.sin(u) + offsetZ;
            this.targetPositions[i*3] = x;
            this.targetPositions[i*3+1] = y;
            this.targetPositions[i*3+2] = z;
        }

        setTargetSpiral(i, turns, radius, height, offsetX=0, offsetY=0, offsetZ=0) {
            const t = (i / this.count) * turns * Math.PI * 2;
            const r = radius * (i / this.count);
            const x = r * Math.cos(t) + offsetX;
            const y = height * ((i / this.count) - 0.5) + offsetY;
            const z = r * Math.sin(t) + offsetZ;
            this.targetPositions[i*3] = x;
            this.targetPositions[i*3+1] = y;
            this.targetPositions[i*3+2] = z;
        }

        setTargetSemiCircle(i, R, thickness=1, offsetX=0, offsetY=0, offsetZ=0) {
            const u = (i / this.count) * Math.PI;
            const x = R * Math.cos(u) + offsetX;
            const y = R * Math.sin(u) + offsetY;
            const z = (this.rand1(i, 5) - 0.5) * thickness + offsetZ;
            this.targetPositions[i*3] = x;
            this.targetPositions[i*3+1] = y;
            this.targetPositions[i*3+2] = z;
        }

        setTargetLightning(i, length, segments, jitter=1, offsetX=0, offsetY=0, offsetZ=0) {
            const t = i / this.count;
            const x = -length * 0.5 + t * length;
            const s = Math.floor(t * segments);
            const dir = (s % 2 === 0) ? 1 : -1;
            const amp = length * 0.1;
            const y = dir * amp + (this.rand1(i, 6) - 0.5) * jitter;
            const z = (this.rand1(i, 7) - 0.5) * jitter;
            this.targetPositions[i*3] = x + offsetX;
            this.targetPositions[i*3+1] = y + offsetY;
            this.targetPositions[i*3+2] = z + offsetZ;
        }

        setTargetCone(i, height, baseR, offsetX=0, offsetY=0, offsetZ=0) {
            const u = (i / this.count) * Math.PI * 2;
            const h = this.rand1(i, 8) * height;
            const r = baseR * (1 - h / height);
            const x = r * Math.cos(u) + offsetX;
            const y = h - height * 0.5 + offsetY;
            const z = r * Math.sin(u) + offsetZ;
            this.targetPositions[i*3] = x;
            this.targetPositions[i*3+1] = y;
            this.targetPositions[i*3+2] = z;
        }

        setTargetHeart(i, scale=8, thickness=2, offsetX=0, offsetY=0, offsetZ=0) {
            const t = (i / this.count) * Math.PI * 2;
            let x = Math.sin(t);
            let y = Math.cos(t);
            x = 16 * Math.pow(x, 3);
            y = 13 * y - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
            x = (x / 16) * scale;
            y = (y / 16) * scale;
            const q = 0.3 + 0.7 * this.rand1(i, 9);
            x *= q;
            y *= q;
            const z = (this.rand1(i, 10) - 0.5) * thickness;
            this.targetPositions[i*3] = x + offsetX;
            this.targetPositions[i*3+1] = y + offsetY;
            this.targetPositions[i*3+2] = z + offsetZ;
        }

        setTargetStar(i, points=5, R=10, r=4, thickness=2, offsetX=0, offsetY=0, offsetZ=0) {
            const a = (i / this.count) * Math.PI * 2;
            const rad = r + (R - r) * 0.5 * (1 + Math.cos(points * a));
            const q = this.rand1(i, 11);
            const x = rad * q * Math.cos(a) + offsetX;
            const y = rad * q * Math.sin(a) + offsetY;
            const z = (this.rand1(i, 12) - 0.5) * thickness + offsetZ;
            this.targetPositions[i*3] = x;
            this.targetPositions[i*3+1] = y;
            this.targetPositions[i*3+2] = z;
        }

        setTargetText(i, scale=10, thickness=1.5, offsetX=0, offsetY=0, offsetZ=0) {
            if (this.textPoints.length === 0) return;
            const idx = Math.floor(this.rand1(i, 40) * this.textPoints.length);
            const p = this.textPoints[idx];
            
            // æ”¾å¤§å€æ•°è°ƒæ•´ï¼Œä½¿æ–‡å­—å¤§å°é€‚ä¸­
            const s = scale * 2.0; 
            const x = p.x * s + offsetX;
            const y = p.y * s + offsetY;
            const z = (this.rand1(i, 41) - 0.5) * thickness + offsetZ;
            
            this.targetPositions[i*3] = x;
            this.targetPositions[i*3+1] = y;
            this.targetPositions[i*3+2] = z;
        }

        setTargetEllipsoid(i, ax=10, ay=6, az=8, offsetX=0, offsetY=0, offsetZ=0) {
            const u = this.rand1(i, 14);
            const v = this.rand1(i, 15);
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            const r = Math.cbrt(this.rand1(i, 16));
            const x = ax * r * Math.sin(phi) * Math.cos(theta) + offsetX;
            const y = ay * r * Math.sin(phi) * Math.sin(theta) + offsetY;
            const z = az * r * Math.cos(phi) + offsetZ;
            this.targetPositions[i*3] = x;
            this.targetPositions[i*3+1] = y;
            this.targetPositions[i*3+2] = z;
        }

        setTargetPyramidSquare(i, base=12, height=10, offsetX=0, offsetY=0, offsetZ=0) {
            const t = this.rand1(i, 17);
            const y = -height * 0.5 + t * height;
            const s = base * (1 - t);
            const x = (this.rand1(i, 18) - 0.5) * s + offsetX;
            const z = (this.rand1(i, 19) - 0.5) * s + offsetZ;
            this.targetPositions[i*3] = x;
            this.targetPositions[i*3+1] = y + offsetY;
            this.targetPositions[i*3+2] = z;
        }

        setTargetCapsule(i, radius=6, halfLen=8, offsetX=0, offsetY=0, offsetZ=0) {
            const w = this.rand1(i, 20);
            if (w < 0.5) {
                const theta = this.rand1(i, 21) * Math.PI * 2;
                const rr = radius * Math.sqrt(this.rand1(i, 22));
                const x = rr * Math.cos(theta) + offsetX;
                const z = rr * Math.sin(theta) + offsetZ;
                const y = (this.rand1(i, 23) * 2 - 1) * halfLen + offsetY;
                this.targetPositions[i*3] = x;
                this.targetPositions[i*3+1] = y;
                this.targetPositions[i*3+2] = z;
            } else {
                const sign = this.rand1(i, 24) < 0.5 ? -1 : 1;
                const theta = this.rand1(i, 25) * Math.PI * 2;
                const phi = this.rand1(i, 26) * Math.PI * 0.5;
                const r = radius * Math.cbrt(this.rand1(i, 27));
                const x = r * Math.sin(phi) * Math.cos(theta) + offsetX;
                const z = r * Math.sin(phi) * Math.sin(theta) + offsetZ;
                const y = sign * halfLen + r * Math.cos(phi) + offsetY;
                this.targetPositions[i*3] = x;
                this.targetPositions[i*3+1] = y;
                this.targetPositions[i*3+2] = z;
            }
        }

        setTargetCuboid(i, w, h, d, offsetX=0, offsetY=0, offsetZ=0) {
            const x = (Math.random() - 0.5) * w + offsetX;
            const y = (Math.random() - 0.5) * h + offsetY;
            const z = (Math.random() - 0.5) * d + offsetZ;
            this.targetPositions[i*3] = x;
            this.targetPositions[i*3+1] = y;
            this.targetPositions[i*3+2] = z;
        }

        setTargetCuboidSurface(i, w, h, d, offsetX=0, offsetY=0, offsetZ=0) {
            const hx = w * 0.5;
            const hy = h * 0.5;
            const hz = d * 0.5;
            const face = i % 6;
            const u = (this.rand1(i, 3) - 0.5);
            const v = (this.rand1(i, 4) - 0.5);
            let x = 0, y = 0, z = 0;
            if (face === 0) { x = hx; y = v * h; z = u * d; }
            else if (face === 1) { x = -hx; y = v * h; z = u * d; }
            else if (face === 2) { y = hy; x = u * w; z = v * d; }
            else if (face === 3) { y = -hy; x = u * w; z = v * d; }
            else if (face === 4) { z = hz; x = u * w; y = v * h; }
            else { z = -hz; x = u * w; y = v * h; }
            this.targetPositions[i*3] = x + offsetX;
            this.targetPositions[i*3+1] = y + offsetY;
            this.targetPositions[i*3+2] = z + offsetZ;
        }

        setTargetCylinder(i, radius, height, offsetX=0, offsetY=0, offsetZ=0) {
            const u = (i / this.count) * Math.PI * 2;
            const y = (this.rand1(i, 28) - 0.5) * height + offsetY;
            const x = radius * Math.cos(u) + offsetX;
            const z = radius * Math.sin(u) + offsetZ;
            this.targetPositions[i*3] = x;
            this.targetPositions[i*3+1] = y;
            this.targetPositions[i*3+2] = z;
        }

        setTargetCrescent(i, R, r, d, thickness, offsetX=0, offsetY=0, offsetZ=0) {
            const u = (i / this.count) * Math.PI * 2;
            const v = (((i * 13) % this.count) / this.count);
            let rad = Math.sqrt(v) * R;
            let x = rad * Math.cos(u);
            let y = rad * Math.sin(u);
            const dx = x - d;
            const dy = y;
            if (dx*dx + dy*dy < r*r) {
                const dirX = Math.cos(u);
                const dirY = Math.sin(u);
                rad = r + (R - r) * v;
                x = rad * dirX;
                y = rad * dirY;
            }
            const z = ( (i * 37) % this.count ) / this.count * thickness - thickness * 0.5;
            this.targetPositions[i*3] = x + offsetX;
            this.targetPositions[i*3+1] = y + offsetY;
            this.targetPositions[i*3+2] = z + offsetZ;
        }

        update() {
            const positions = this.geometry.attributes.position.array;
            for(let i=0; i<this.count; i++) {
                const s = this.shapeScale;
                if (this.currentShape === 'sphere') {
                    this.setTargetSphere(i, s, 0, 0, 0);
                } else if (this.currentShape === 'cube') {
                    this.setTargetCubeSurface(i, s * 1.4, 0, 0, 0);
                } else if (this.currentShape === 'torus') {
                    this.setTargetTorus(i, s * 1.2, s * 0.35, 0, 0, 0);
                } else if (this.currentShape === 'spiral') {
                    this.setTargetSpiral(i, 6, s * 1.4, s * 1.0, 0, 0, 0);
                } else if (this.currentShape === 'cuboid') {
                    this.setTargetCuboidSurface(i, s * 1.5, s, s * 0.8, 0, 0, 0);
                } else if (this.currentShape === 'cylinder') {
                    this.setTargetCylinder(i, s, s * 1.6, 0, 0, 0);
                } else if (this.currentShape === 'crescent') {
                    this.setTargetCrescent(i, s * 1.2, s * 0.8, s * 0.6, s * 0.3, 0, 0, 0);
                } else if (this.currentShape === 'semicircle') {
                    this.setTargetSemiCircle(i, s * 1.2, s * 0.2, 0, 0, 0);
                } else if (this.currentShape === 'lightning') {
                    this.setTargetLightning(i, s * 2.0, 14, 1.5, 0, 0, 0);
                } else if (this.currentShape === 'cone') {
                    this.setTargetCone(i, s * 1.2, s * 0.9, 0, 0, 0);
                } else if (this.currentShape === 'heart') {
                    this.setTargetHeart(i, s, s * 0.15, 0, 0, 0);
                } else if (this.currentShape === 'star') {
                    this.setTargetStar(i, 5, s * 1.1, s * 0.5, s * 0.15, 0, 0, 0);
                } else if (this.currentShape === 'text') {
                    this.setTargetText(i, s * 0.5, s * 0.2, 0, 0, 0);
                } else if (this.currentShape === 'ellipsoid') {
                    this.setTargetEllipsoid(i, s * 1.1, s * 0.8, s * 1.0, 0, 0, 0);
                } else if (this.currentShape === 'pyramid') {
                    this.setTargetPyramidSquare(i, s * 1.2, s, 0, 0, 0);
                } else if (this.currentShape === 'capsule') {
                    this.setTargetCapsule(i, s * 0.6, s * 1.0, 0, 0, 0);
                } else {
                    this.setTargetSphere(i, s, 0, 0, 0);
                }
                const speed = 0.05;
                positions[i*3]   += (this.targetPositions[i*3] - positions[i*3]) * speed;
                positions[i*3+1] += (this.targetPositions[i*3+1] - positions[i*3+1]) * speed;
                positions[i*3+2] += (this.targetPositions[i*3+2] - positions[i*3+2]) * speed;
            }
            
            this.geometry.attributes.position.needsUpdate = true;
            
            this.mesh.rotation.y += this.rotationSpeed;
        }

        updateSettings(prop, value) {
            if(prop === 'color') this.material.color.set(value);
            if(prop === 'size') this.material.size = value;
            if(prop === 'shapeType') {
                this.shapeType = value;
                this.material.map = createTexture(value);
            }
        }
        
        setCount(newCount) {
            newCount = Math.max(100, Math.floor(newCount));
            if (newCount === this.count) return;
            this.count = newCount;
            this.positions = new Float32Array(this.count * 3);
            this.targetPositions = new Float32Array(this.count * 3);
            for (let i = 0; i < this.count; i++) {
                const s = this.shapeScale;
                if (this.currentShape === 'sphere') {
                    this.setTargetSphere(i, s, 0, 0, 0);
                } else if (this.currentShape === 'cube') {
                    this.setTargetCubeSurface(i, s * 1.4, 0, 0, 0);
                } else if (this.currentShape === 'torus') {
                    this.setTargetTorus(i, s * 1.2, s * 0.35, 0, 0, 0);
                } else if (this.currentShape === 'spiral') {
                    this.setTargetSpiral(i, 6, s * 1.4, s * 1.0, 0, 0, 0);
                } else if (this.currentShape === 'cuboid') {
                    this.setTargetCuboidSurface(i, s * 1.5, s, s * 0.8, 0, 0, 0);
                } else if (this.currentShape === 'cylinder') {
                    this.setTargetCylinder(i, s, s * 1.6, 0, 0, 0);
                } else if (this.currentShape === 'crescent') {
                    this.setTargetCrescent(i, s * 1.2, s * 0.8, s * 0.6, s * 0.3, 0, 0, 0);
                } else if (this.currentShape === 'semicircle') {
                    this.setTargetSemiCircle(i, s * 1.2, s * 0.2, 0, 0, 0);
                } else if (this.currentShape === 'lightning') {
                    this.setTargetLightning(i, s * 2.0, 14, 1.5, 0, 0, 0);
                } else if (this.currentShape === 'cone') {
                    this.setTargetCone(i, s * 1.2, s * 0.9, 0, 0, 0);
                } else if (this.currentShape === 'heart') {
                    this.setTargetHeart(i, s, s * 0.15, 0, 0, 0);
                } else if (this.currentShape === 'star') {
                    this.setTargetStar(i, 5, s * 1.1, s * 0.5, s * 0.15, 0, 0, 0);
                } else if (this.currentShape === 'text') {
                    this.setTargetText(i, s * 0.5, s * 0.2, 0, 0, 0);
                } else if (this.currentShape === 'ellipsoid') {
                    this.setTargetEllipsoid(i, s * 1.1, s * 0.8, s * 1.0, 0, 0, 0);
                } else if (this.currentShape === 'pyramid') {
                    this.setTargetPyramidSquare(i, s * 1.2, s, 0, 0, 0);
                } else if (this.currentShape === 'capsule') {
                    this.setTargetCapsule(i, s * 0.6, s * 1.0, 0, 0, 0);
                } else {
                    this.setTargetSphere(i, s, 0, 0, 0);
                }
                this.positions[i*3] = this.targetPositions[i*3];
                this.positions[i*3+1] = this.targetPositions[i*3+1];
                this.positions[i*3+2] = this.targetPositions[i*3+2];
            }
            this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
            this.geometry.computeBoundingSphere();
        }
        
        dispose() {
            scene.remove(this.mesh);
            this.geometry.dispose();
            this.material.dispose();
        }
    }

    /**
     * 3. ä¸»ç¨‹åºé€»è¾‘
     */
    function init() {
        // åœºæ™¯è®¾ç½®
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.02);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        updateCameraPosition();

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // é»˜è®¤åˆ›å»ºä¸€ä¸ªç²’å­ç¾¤
        addParticleSystem();

        // UI åˆå§‹åŒ–
        initGUI();
        
        // äº‹ä»¶ç›‘å¬
        window.addEventListener('resize', onWindowResize);
        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('fullscreenchange', updateFullscreenButton);
        document.getElementById('fullscreen-btn').addEventListener('click', toggleFullScreen);
        setupMouseControls();
        setupTouchControls();
        setupDpad();

        // å¯åŠ¨å¾ªç¯
        animate();
    }

    function setupDpad() {
        const speed = 0.1;
        const dpadUp = document.getElementById('dpad-up');
        const dpadDown = document.getElementById('dpad-down');
        const dpadLeft = document.getElementById('dpad-left');
        const dpadRight = document.getElementById('dpad-right');

        let dpadInterval = null;

        const startMove = (dx, dy) => {
            resetUIHideTimer();
            if (dpadInterval) clearInterval(dpadInterval);
            dpadInterval = setInterval(() => {
                camAngle += dx * speed * 0.5;
                camHeight += dy * 0.5;
                if (camHeight > 20) camHeight = 20;
                if (camHeight < -20) camHeight = -20;
                updateCameraPosition();
            }, 30);
        };

        const stopMove = () => {
            if (dpadInterval) clearInterval(dpadInterval);
            dpadInterval = null;
        };

        const bindDpad = (el, dx, dy) => {
            el.addEventListener('touchstart', (e) => { e.preventDefault(); startMove(dx, dy); });
            el.addEventListener('touchend', (e) => { e.preventDefault(); stopMove(); });
            el.addEventListener('mousedown', (e) => { e.preventDefault(); startMove(dx, dy); });
            el.addEventListener('mouseup', (e) => { e.preventDefault(); stopMove(); });
            el.addEventListener('mouseleave', (e) => { e.preventDefault(); stopMove(); });
        };

        bindDpad(dpadLeft, 1, 0); // Left arrow rotates camera right (scene moves left)
        bindDpad(dpadRight, -1, 0); // Right arrow rotates camera left
        bindDpad(dpadUp, 0, 1);
        bindDpad(dpadDown, 0, -1);
    }

    function setupTouchControls() {
        const dom = renderer.domElement;
        dom.addEventListener('touchstart', onTouchStart, {passive: false});
        dom.addEventListener('touchmove', onTouchMove, {passive: false});
        dom.addEventListener('touchend', onTouchEnd, {passive: false});
    }

    function onTouchStart(e) {
        resetUIHideTimer();
        if(e.touches.length === 1) {
            // åœ¨ç§»åŠ¨è®¾å¤‡ä¸Šï¼Œä¸è¦ preventDefault æ‰€æœ‰å•æŒ‡è§¦æ‘¸
            // åªæœ‰å½“æˆ‘ä»¬éœ€è¦æ¥ç®¡ï¼ˆå¦‚åœ¨ canvas ä¸Šï¼‰æ—¶æ‰ preventDefault
            // ä½†æ˜¯ï¼Œè¿™é‡Œæˆ‘ä»¬ç¡®å®æ˜¯åœ¨ canvas ä¸Šæ“ä½œï¼Œæ‰€ä»¥ preventDefault æ˜¯å¯¹çš„ï¼Œé˜²æ­¢æ»šåŠ¨
            // é—®é¢˜å¯èƒ½åœ¨äº preventDefault é˜»æ­¢äº† click äº‹ä»¶çš„ç”Ÿæˆ
            // å¦‚æœæˆ‘ä»¬ä¾èµ– click äº‹ä»¶æ¥è§¦å‘æŸäº›é€»è¾‘ï¼ˆè™½ç„¶è¿™é‡Œä¸»è¦æ˜¯ mouse down/move/upï¼‰
            
            // é‡è¦ï¼šä¸ºäº†å…¼å®¹æ€§ï¼Œæˆ‘ä»¬éœ€è¦ç¡®ä¿ onMouseDown è¢«æ­£ç¡®è°ƒç”¨
            e.preventDefault(); 
            const touch = e.touches[0];
            const mockEvent = {
                clientX: touch.clientX,
                clientY: touch.clientY,
                preventDefault: () => {}
            };
            
            // è°ƒè¯•æ—¥å¿—
            // console.log('Touch Start', touch.clientX, touch.clientY);
            
            onMouseDown(mockEvent);

            // å¯åŠ¨é•¿æŒ‰å®šæ—¶å™¨
            if (selectedSystem) {
                longPressTimer = setTimeout(() => {
                    openSettingsPanel(selectedSystem);
                    longPressTimer = null;
                }, LONG_PRESS_DURATION);
            }
        } else if (e.touches.length === 2 && selectedSystem) {
            if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; }
            e.preventDefault();
            isPinching = true;
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            initialPinchDistance = Math.sqrt(dx * dx + dy * dy);
            initialScale = selectedSystem.mesh.scale.x;
            lastPinchAngle = Math.atan2(dy, dx);
        } else if (e.touches.length === 3 && selectedSystem) {
            if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; }
            e.preventDefault();
            isThreeFinger = true;
            // è®¡ç®—ä¸‰æŒ‡çš„å¹³å‡Yåæ ‡
            lastThreeFingerY = (e.touches[0].clientY + e.touches[1].clientY + e.touches[2].clientY) / 3;
        }
    }

    function onTouchMove(e) {
        if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; }
        if(e.touches.length === 1 && !isPinching && !isThreeFinger) {
            e.preventDefault();
            const touch = e.touches[0];
            const mockEvent = {
                clientX: touch.clientX,
                clientY: touch.clientY,
                preventDefault: () => {}
            };
            onMouseMove(mockEvent);
        } else if (e.touches.length === 2 && isPinching && selectedSystem) {
            e.preventDefault();
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            
            // ç¼©æ”¾é€»è¾‘
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (initialPinchDistance > 0) {
                const scale = (distance / initialPinchDistance) * initialScale;
                const clampedScale = Math.max(0.1, Math.min(scale, 10.0));
                selectedSystem.mesh.scale.set(clampedScale, clampedScale, clampedScale);
            }

            // æ—‹è½¬é€»è¾‘ (æ°´å¹³æ—‹è½¬ Yè½´)
            const currAngle = Math.atan2(dy, dx);
            let dAngle = currAngle - lastPinchAngle;
            // å¤„ç†è§’åº¦çªå˜ (å¦‚ä» PI è·³å˜åˆ° -PI)
            if (dAngle > Math.PI) dAngle -= 2 * Math.PI;
            else if (dAngle < -Math.PI) dAngle += 2 * Math.PI;
            
            // å¢åŠ çµæ•åº¦ç³»æ•°ï¼Œä½¿æ—‹è½¬æ›´è·Ÿæ‰‹ (å¯é€‰)
            selectedSystem.mesh.rotation.y += dAngle; 
            
            lastPinchAngle = currAngle;
        } else if (e.touches.length === 3 && isThreeFinger && selectedSystem) {
            e.preventDefault();
            const currentY = (e.touches[0].clientY + e.touches[1].clientY + e.touches[2].clientY) / 3;
            const dy = currentY - lastThreeFingerY;
            
            // å‚ç›´æ—‹è½¬ (Xè½´)ï¼Œçµæ•åº¦ 0.01
            selectedSystem.mesh.rotation.x += dy * 0.01;
            
            lastThreeFingerY = currentY;
        }
    }

    function onTouchEnd(e) {
        if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; }
        if (e.touches.length < 3) {
            isThreeFinger = false;
        }
        if (e.touches.length < 2) {
            isPinching = false;
        }
        if (e.touches.length === 0) {
            onMouseUp();
        }
    }

    function setupMouseControls() {
        const dom = renderer.domElement;
        dom.addEventListener('mousedown', onMouseDown);
        dom.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', onMouseUp);
    }

    function getMouseNDC(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    }

    function onMouseDown(event) {
        resetUIHideTimer();
        getMouseNDC(event);
        raycaster.setFromCamera(mouse, camera);
        const meshes = particleSystems.map(s => s.mesh);
        const intersects = raycaster.intersectObjects(meshes, true);
        if (intersects.length > 0) {
            const mesh = intersects[0].object;
            selectedSystem = particleSystems.find(s => s.mesh === mesh) || null;
            if (selectedSystem) {
                // é€‰ä¸­æ—¶è‡ªåŠ¨æ‰“å¼€è®¾ç½®é¢æ¿
                openSettingsPanel(selectedSystem);
            }
            const planePoint = selectedSystem.mesh.position.clone();
            const planeNormal = camera.getWorldDirection(new THREE.Vector3());
            dragPlane.setFromNormalAndCoplanarPoint(planeNormal, planePoint);
            const p = new THREE.Vector3();
            raycaster.ray.intersectPlane(dragPlane, p);
            if (p) { // Check if intersection exists
                dragOffset.copy(selectedSystem.mesh.position).sub(p);
                isDragging = true;
                pinchSession.active = false;
                pinchSession.handIndex = -1;
            }
        } else {
            selectedSystem = null;
            isDragging = false;
        }
    }

    function onMouseMove(event) {
        resetUIHideTimer();
        if (!isDragging || !selectedSystem) return;
        getMouseNDC(event);
        raycaster.setFromCamera(mouse, camera);
        const p = new THREE.Vector3();
        raycaster.ray.intersectPlane(dragPlane, p);
        if (p) {
             selectedSystem.mesh.position.copy(p.add(dragOffset));
        }
    }

    function onMouseUp() {
        isDragging = false;
    }

    function addParticleSystem(config = {}) {
        const id = Date.now();
        if (!config.currentShape) {
            const idx = Math.floor(Math.random() * AVAILABLE_SHAPES.length);
            config.currentShape = AVAILABLE_SHAPES[idx];
        }
        if (config.shapeScale == null) {
            config.shapeScale = 15;
        }
        const sys = new ParticleCloud(id, config);
        particleSystems.push(sys);
        selectedSystem = sys;
        refreshGUI(); // åˆ·æ–°UIä»¥æ˜¾ç¤ºæ–°ç³»ç»Ÿ
    }

    function removeParticleSystem(sys) {
        sys.dispose();
        particleSystems = particleSystems.filter(s => s.id !== sys.id);
        if (selectedSystem && selectedSystem.id === sys.id) {
            selectedSystem = particleSystems[particleSystems.length - 1] || null;
        }
        refreshGUI();
    }

    function duplicateParticleSystem(sys) {
        const conf = {
            count: sys.count,
            color: '#' + sys.material.color.getHexString(),
            size: sys.material.size,
            shapeType: sys.shapeType,
            currentShape: sys.currentShape,
            shapeScale: sys.shapeScale,
            rotationSpeed: sys.rotationSpeed,
            textString: sys.textString,
            scale: {
                x: sys.mesh.scale.x,
                y: sys.mesh.scale.y,
                z: sys.mesh.scale.z
            },
            position: {
                x: sys.mesh.position.x + 2,
                y: sys.mesh.position.y,
                z: sys.mesh.position.z
            }
        };
        addParticleSystem(conf);
    }

    function clearCanvas() {
        particleSystems.forEach(sys => sys.dispose());
        particleSystems = [];
        selectedSystem = null;
        refreshGUI();
    }

    function openSettingsPanel(sys) {
        if (!sys) return;
        // æ‰¾åˆ°å¯¹åº”çš„ folder
        // ç”±äº lil-gui æ²¡æœ‰ç›´æ¥æä¾›é€šè¿‡å¯¹è±¡æŸ¥æ‰¾ folder çš„ APIï¼Œæˆ‘ä»¬éœ€è¦é‡æ–°æ‰“å¼€å¯¹åº”å±‚çº§
        // æˆ–è€…ç®€å•åœ°ï¼Œæˆ‘ä»¬å¯ä»¥æŠ˜å æ‰€æœ‰ï¼Œåªå±•å¼€é€‰ä¸­çš„é‚£ä¸ª
        if (gui) {
            const controllers = gui.folders;
            // å‡è®¾ folder çš„ title åŒ…å« indexï¼Œè¿™é‡Œæˆ‘ä»¬ç”¨æ›´ç®€å•çš„æ–¹å¼ï¼š
            // æˆ‘ä»¬åœ¨åˆ›å»º folder æ—¶æ²¡æœ‰ä¿å­˜å¼•ç”¨æ˜ å°„ï¼Œç°åœ¨å¯ä»¥ç®€å•åœ°éå†
            // æˆ–è€…é‡æ–°åˆ·æ–° GUI å¹¶é«˜äº®
            // ä¸ºäº†ç®€å•æœ‰æ•ˆï¼Œæˆ‘ä»¬é‡æ–°éå† folders
            let foundIndex = -1;
            particleSystems.forEach((s, i) => {
                if (s.id === sys.id) foundIndex = i;
            });
            
            if (foundIndex !== -1 && gui.folders.length > foundIndex + 2) { 
                // gui.folders[0] is Global, [1] is Gesture, so particle systems start from 2
                // ä½†æ˜¯ lil-gui çš„ folders æ˜¯æ•°ç»„å—ï¼Ÿ API å˜åŠ¨å¯èƒ½å¯¼è‡´é—®é¢˜
                // å®‰å…¨èµ·è§ï¼Œæˆ‘ä»¬éå† children
                let idx = 0;
                for (let i = 0; i < gui.children.length; i++) {
                    const child = gui.children[i];
                    if (child instanceof lil.GUI) { // æ˜¯ä¸ª folder
                         // æˆ‘ä»¬å¯ä»¥æ£€æŸ¥ title
                         if (child._title === `ç²’å­ç¾¤ ${foundIndex + 1}`) {
                             child.open();
                             // æ»šåŠ¨åˆ°è¯¥ä½ç½® (å¦‚æœæ”¯æŒ)
                             child.domElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                         } else {
                             child.close();
                         }
                    }
                }
            }
        }
    }

    /**
     * GUI è®¾ç½®é¢æ¿ (ä½¿ç”¨ Lil-GUI)
     */
    function initGUI() {
        refreshGUI();
    }

    function refreshGUI() {
        if (gui && typeof gui.destroy === 'function') {
            gui.destroy();
        }
        gui = new lil.GUI({ title: 'æ§åˆ¶é¢æ¿' });
        gui.domElement.style.position = 'fixed';
        gui.domElement.style.bottom = '20px';
        gui.domElement.style.right = '20px';
        gui.domElement.style.top = 'auto';
        gui.domElement.style.left = 'auto';
        gui.domElement.style.zIndex = '100';

        const globalConfig = {
            addSystem: () => addParticleSystem({ 
                color: '#' + Math.floor(Math.random()*16777215).toString(16),
                shapeType: 'glow' 
            }),
            clearCanvas: () => clearCanvas(),
            exportFile: () => exportStateToFile(),
            importFile: () => importStateFromFile()
        };

        const folderGlobal = gui.addFolder('å…¨å±€æ§åˆ¶');
        folderGlobal.add(globalConfig, 'addSystem').name('æ·»åŠ æ–°ç²’å­ç¾¤');
        folderGlobal.add(globalConfig, 'clearCanvas').name('æ¸…ç©ºç”»å¸ƒ');
        
        folderGlobal.add(globalConfig, 'exportFile').name('å¯¼å‡ºåˆ°æ–‡ä»¶');
        folderGlobal.add(globalConfig, 'importFile').name('ä»æ–‡ä»¶åŠ è½½');

        const folderGesture = gui.addFolder('æ‰‹åŠ¿å‚æ•°');
        folderGesture.add(gestureConfig, 'pinchThreshold', 0.03, 0.2, 0.001).name('æåˆé˜ˆå€¼');
        folderGesture.add(gestureConfig, 'followLerp', 0.05, 0.6, 0.01).name('è·Ÿéšå¹³æ»‘');
        folderGesture.add(gestureConfig, 'worldScaleX', 10, 60, 1).name('Xæ˜ å°„å°ºåº¦');
        folderGesture.add(gestureConfig, 'worldScaleY', 10, 60, 1).name('Yæ˜ å°„å°ºåº¦');
        folderGesture.add(gestureConfig, 'openScore', 0.08, 0.35, 0.005).name('å¼ å¼€é˜ˆå€¼');
        folderGesture.add(gestureConfig, 'fistScore', 0.05, 0.25, 0.005).name('æ¡æ‹³é˜ˆå€¼');
        folderGesture.add(gestureConfig, 'scaleMin', 0.2, 1.0, 0.05).name('ç¼©æ”¾ä¸‹é™');
        folderGesture.add(gestureConfig, 'scaleMax', 1.0, 4.0, 0.1).name('ç¼©æ”¾ä¸Šé™');
        folderGesture.add(gestureConfig, 'scaleLerp', 0.05, 0.6, 0.01).name('ç¼©æ”¾å¹³æ»‘');

        // ä¸ºæ¯ä¸ªç²’å­ç³»ç»Ÿåˆ›å»ºæ–‡ä»¶å¤¹
        particleSystems.forEach((sys, index) => {
            const folder = gui.addFolder(`ç²’å­ç¾¤ ${index + 1}`);
            
            const params = {
                color: '#' + sys.material.color.getHexString(),
                size: sys.material.size,
                type: sys.shapeType,
                count: sys.count,
                delete: () => removeParticleSystem(sys),
                duplicate: () => duplicateParticleSystem(sys),
                shape: sys.currentShape,
                shapeScale: sys.shapeScale,
                rotationSpeed: sys.rotationSpeed,
                textString: sys.textString
            };

            folder.addColor(params, 'color').name('é¢œè‰²').onChange(v => sys.updateSettings('color', v));
            folder.add(params, 'size', 0.01, 1).name('é¢—ç²’å¤§å°').onChange(v => sys.updateSettings('size', v));
            folder.add(params, 'type', ['glow', 'rain', 'snow', 'square']).name('å½¢çŠ¶/æè´¨').onChange(v => sys.updateSettings('shapeType', v));
            folder.add(params, 'count', 200, 10000, 100).name('ç¦»å­å¯†åº¦').onChange(v => { sys.setCount(v); });
            folder.add(params, 'rotationSpeed', -0.02, 0.02, 0.0005).name('æ—‹è½¬é€Ÿåº¦').onChange(v => { sys.rotationSpeed = v; });
            folder.add(params, 'shape', ['sphere','cube','cuboid','cylinder','torus','spiral','crescent','semicircle','lightning','cone','heart','star','text','ellipsoid','pyramid','capsule']).name('å‡ ä½•å½¢çŠ¶').onChange(v => { sys.currentShape = v; });
            folder.add(params, 'textString').name('æ–‡å­—å†…å®¹(ä»…Textæœ‰æ•ˆ)').onChange(v => { sys.setText(v); });
            folder.add(params, 'shapeScale', 5, 40, 1).name('å½¢çŠ¶å°ºå¯¸').onChange(v => { sys.shapeScale = v; });
            folder.add(params, 'delete').name('åˆ é™¤æ­¤ç¾¤');
            folder.add(params, 'duplicate').name('å¤åˆ¶æ­¤ç¾¤');
        });
    }

    /**
     * é”®ç›˜æ§åˆ¶æ‘„åƒå¤´
     */
    function onKeyDown(e) {
        const speed = 0.1;
        switch(e.key) {
            case 'ArrowLeft': camAngle += speed; break;
            case 'ArrowRight': camAngle -= speed; break;
            case 'ArrowUp': if(camHeight < 20) camHeight += 1; break;
            case 'ArrowDown': if(camHeight > -20) camHeight -= 1; break;
        }
        updateCameraPosition();
    }

    function updateCameraPosition() {
        camera.position.x = Math.sin(camAngle) * CAM_RADIUS;
        camera.position.z = Math.cos(camAngle) * CAM_RADIUS;
        camera.position.y = camHeight;
        camera.lookAt(0, 0, 0);
    }

    function showToast(msg) {
        const toast = document.getElementById('toast');
        toast.innerText = msg;
        toast.classList.add('show');
        if (toastTimer) clearTimeout(toastTimer);
        toastTimer = setTimeout(() => {
            toast.classList.remove('show');
        }, 2000);
    }

    /**
     * å­˜å‚¨åŠŸèƒ½
     */
    function getSystemData() {
        return particleSystems.map(sys => ({
            count: sys.count,
            color: '#' + sys.material.color.getHexString(),
            size: sys.material.size,
            shapeType: sys.shapeType,
            currentShape: sys.currentShape,
            shapeScale: sys.shapeScale,
            rotationSpeed: sys.rotationSpeed,
            textString: sys.textString,
            scale: {
                x: sys.mesh.scale.x,
                y: sys.mesh.scale.y,
                z: sys.mesh.scale.z
            },
            position: {
                x: sys.mesh.position.x,
                y: sys.mesh.position.y,
                z: sys.mesh.position.z
            }
        }));
    }

    function saveState() {
        const data = getSystemData();
        localStorage.setItem('particleData', JSON.stringify(data));
        showToast('é…ç½®å·²ä¿å­˜ï¼');
    }

    function loadState() {
        const raw = localStorage.getItem('particleData');
        if(!raw) { showToast('æ²¡æœ‰æ‰¾åˆ°å­˜æ¡£'); return; }
        
        // æ¸…é™¤ç°æœ‰
        particleSystems.forEach(s => s.dispose());
        particleSystems = [];
        
        const data = JSON.parse(raw);
        data.forEach(conf => addParticleSystem(conf));
        showToast('é…ç½®å·²åŠ è½½');
    }

    async function exportStateToFile() {
        const data = getSystemData();
        const jsonStr = JSON.stringify(data, null, 2);
        const fileName = `particle_state_${Date.now()}.json`;
        
        // å°è¯•ä½¿ç”¨ Web Share API
        // æ³¨æ„ï¼šiPad ä¸Š navigator.share è™½ç„¶å­˜åœ¨ï¼Œä½†å¯¹äº file ç±»å‹çš„åˆ†äº«æ”¯æŒå¯èƒ½æœ‰é™
        // æˆ–è€…ç”¨æˆ·å¯èƒ½ä¸æ¸…æ¥šåˆ†äº«åˆ°äº†å“ªé‡Œã€‚
        // ä¸ºäº†ç¡®ä¿èƒ½ä¿å­˜ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ iPad ä¸Šè·³è¿‡ Web Shareï¼Œç›´æ¥èµ°ä¸‹è½½æµç¨‹
        // æˆ–è€…ä¿ç•™ Web Share ä½†æä¾›æ˜ç¡®åé¦ˆã€‚
        // é‰´äº iPadOS Safari å¯¹ blob ä¸‹è½½çš„æ”¯æŒå·²ç»å¾ˆå¥½ï¼ˆä¼šä¿å­˜åˆ°â€œä¸‹è½½â€æ–‡ä»¶å¤¹ï¼‰ï¼Œ
        // å¼ºåˆ¶èµ°ä¸‹è½½å¯èƒ½æ›´ç›´è§‚ã€‚
        // æ£€æµ‹æ˜¯å¦ä¸º iPadOS
        const isIPad = navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1;

        if (!isIPad && navigator.share && navigator.canShare) {
             const file = new File([jsonStr], fileName, { type: 'application/json' });
             const shareData = {
                 files: [file],
                 title: 'ç²’å­ç³»ç»Ÿé…ç½®',
                 text: 'åˆ†äº«æˆ‘çš„ç²’å­ç³»ç»Ÿé…ç½®'
             };
             if (navigator.canShare(shareData)) {
                 try {
                     await navigator.share(shareData);
                     showToast('åˆ†äº«æˆåŠŸ');
                     return;
                 } catch (err) {
                     console.log('Share failed or canceled', err);
                     // Fallback to download
                 }
             }
        }

        const blob = new Blob([jsonStr], { type: 'application/json' });
        if (isIPad) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const url = e.target.result; // Data URL
                
                // å°è¯•åˆ›å»ºä¸€ä¸ªä¸´æ—¶çš„é”šç‚¹å¹¶æ¨¡æ‹Ÿç‚¹å‡»ï¼Œå¼ºåˆ¶ä¸‹è½½
                const tempLink = document.createElement('a');
                tempLink.href = url;
                tempLink.download = fileName; // å°è¯•æŒ‡å®šæ–‡ä»¶å
                tempLink.style.display = 'none';
                document.body.appendChild(tempLink);
                
                // å¯¹äº iPadï¼Œæœ‰æ—¶ target="_blank" ä¼šæ›´æœ‰æ•ˆ
                tempLink.target = '_blank';
                
                tempLink.click();
                
                setTimeout(() => {
                    document.body.removeChild(tempLink);
                    showToast('å·²å°è¯•æ‰“å¼€/ä¸‹è½½ï¼Œè¯·æ£€æŸ¥å¼¹çª—æˆ–åˆ†äº«');
                }, 100);
            };
            reader.readAsDataURL(blob);
            return;
        }

        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = fileName;
        document.body.appendChild(a); // å…¼å®¹æ€§ï¼šæŸäº›æµè§ˆå™¨éœ€è¦æ·»åŠ åˆ° DOM
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
        showToast('å·²å°è¯•ä¸‹è½½ï¼Œè¯·æ£€æŸ¥â€œæ–‡ä»¶â€App');
    }

    function importStateFromFile() {
        const input = document.createElement('input');
        input.type = 'file';
        // iOS ä¸Š .json æœ‰æ—¶æ— æ³•é€‰æ‹©ï¼Œå¢åŠ  text/plain å’Œ */* å¢åŠ å…¼å®¹æ€§
        input.accept = '.json,application/json,text/plain'; 
        input.onchange = () => {
            const file = input.files && input.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = () => {
                try {
                    const data = JSON.parse(reader.result);
                    particleSystems.forEach(s => s.dispose());
                    particleSystems = [];
                    data.forEach(conf => addParticleSystem(conf));
                    refreshGUI();
                    showToast('æ–‡ä»¶å·²åŠ è½½');
                } catch (e) {
                    showToast('æ–‡ä»¶è§£æå¤±è´¥');
                }
            };
            reader.readAsText(file);
        };
        input.click();
    }

    // è‡ªåŠ¨ä¿å­˜é€»è¾‘
    const AUTOSAVE_KEY = 'snowball_autosave';
    
    function autoSave() {
        const data = getSystemData();
        localStorage.setItem(AUTOSAVE_KEY, JSON.stringify(data));
    }

    function loadAutoSave() {
        const raw = localStorage.getItem(AUTOSAVE_KEY);
        if (raw) {
            try {
                const data = JSON.parse(raw);
                if (data && data.length > 0) {
                    particleSystems.forEach(s => s.dispose());
                    particleSystems = [];
                    data.forEach(conf => addParticleSystem(conf));
                    refreshGUI();
                    showToast('å·²æ¢å¤è‡ªåŠ¨å­˜æ¡£');
                }
            } catch (e) {
                console.error('Auto load failed', e);
            }
        }
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function toggleFullScreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen();
        } else {
            if (document.exitFullscreen) document.exitFullscreen();
        }
    }

    function updateFullscreenButton() {
        const btn = document.getElementById('fullscreen-btn');
        if (document.fullscreenElement) {
            btn.innerText = "é€€å‡ºå…¨å±æ¨¡å¼";
            resetUIHideTimer();
        } else {
            btn.innerText = "å…¨å±æ¨¡å¼";
            showUI();
            if (uiHideTimer) clearTimeout(uiHideTimer);
        }
    }

    function hideUI() {
        if (!document.fullscreenElement) return;
        document.getElementById('ui-layer').classList.add('fade-out');
        document.getElementById('fullscreen-btn').classList.add('fade-out');
        document.getElementById('dpad-container').classList.add('fade-out');
        if (gui) gui.domElement.classList.add('fade-transition', 'fade-out');
    }

    function showUI() {
        document.getElementById('ui-layer').classList.remove('fade-out');
        document.getElementById('fullscreen-btn').classList.remove('fade-out');
        document.getElementById('dpad-container').classList.remove('fade-out');
        if (gui) {
            gui.domElement.classList.add('fade-transition'); // Ensure class exists
            gui.domElement.classList.remove('fade-out');
        }
    }

    function resetUIHideTimer() {
        if (!document.fullscreenElement) return;
        showUI();
        if (uiHideTimer) clearTimeout(uiHideTimer);
        uiHideTimer = setTimeout(hideUI, UI_HIDE_DELAY);
    }

    function animate() {
        requestAnimationFrame(animate);
        if (selectedSystem && handLandmarks && handLandmarks.length >= 1 && !isDragging) {
            const pinchInfo = (hand) => {
                const t = hand[4];
                const i = hand[8];
                const d = Math.hypot(t.x - i.x, t.y - i.y);
                const mx = (t.x + i.x) * 0.5;
                const my = (t.y + i.y) * 0.5;
                return { d, mx, my };
            };
            const TH = gestureConfig.pinchThreshold;
            let idx = -1;
            let info = null;
            for (let k = 0; k < handLandmarks.length; k++) {
                const p = pinchInfo(handLandmarks[k]);
                if (p.d < TH) { idx = k; info = p; break; }
            }
            if (idx !== -1) {
                const wx = (0.5 - info.mx) * gestureConfig.worldScaleX;
                const wy = (0.5 - info.my) * gestureConfig.worldScaleY;
                const curWorld = new THREE.Vector3(wx, wy, 0);
                if (!pinchSession.active || pinchSession.handIndex !== idx) {
                    if (particleSystems.length > 0) {
                        let nearest = particleSystems[0];
                        let minDist = nearest.mesh.position.distanceTo(curWorld);
                        for (let s = 1; s < particleSystems.length; s++) {
                            const d = particleSystems[s].mesh.position.distanceTo(curWorld);
                            if (d < minDist) { minDist = d; nearest = particleSystems[s]; }
                        }
                        selectedSystem = nearest;
                        // æ‰‹åŠ¿é€‰ä¸­æ—¶ä¹Ÿè‡ªåŠ¨æ‰“å¼€é¢æ¿
                        openSettingsPanel(selectedSystem);
                    }
                    pinchSession.active = true;
                    pinchSession.handIndex = idx;
                    pinchSession.startWorld.copy(curWorld);
                    pinchSession.startGroupPos.copy(selectedSystem.mesh.position);
                }
                const delta = curWorld.clone().sub(pinchSession.startWorld);
                const targetPos = pinchSession.startGroupPos.clone().add(delta);
                selectedSystem.mesh.position.lerp(targetPos, gestureConfig.followLerp);

                if (handLandmarks.length >= 2) {
                    let other = null;
                    let otherIdx = -1;
                    for (let k = 0; k < handLandmarks.length; k++) {
                        if (k !== idx) { other = handLandmarks[k]; otherIdx = k; break; }
                    }
                    if (other) {
                        // 1. ç¼©æ”¾é€»è¾‘ (åŸæœ‰çš„)
                        const pairs = [[8,5],[12,9],[16,13],[20,17]];
                        let score = 0;
                        for (let p = 0; p < pairs.length; p++) {
                            const tip = other[pairs[p][0]];
                            const base = other[pairs[p][1]];
                            score += Math.hypot(tip.x - base.x, tip.y - base.y);
                        }
                        score /= pairs.length;
                        const OPEN_S = gestureConfig.openScore;
                        const FIST_S = gestureConfig.fistScore;
                        const scaleMin = gestureConfig.scaleMin;
                        const scaleMax = gestureConfig.scaleMax;
                        const cur = selectedSystem.mesh.scale.x;
                        let goal = cur;
                        if (score >= OPEN_S) goal = scaleMax;
                        else if (score <= FIST_S) goal = scaleMin;
                        const kScale = gestureConfig.scaleLerp;
                        const ns = cur + (goal - cur) * kScale;
                        selectedSystem.mesh.scale.set(ns, ns, ns);

                        // 2. æ—‹è½¬é€»è¾‘ (æ–°å¢)
                        // ä½¿ç”¨å¦ä¸€åªæ‰‹çš„æ‰‹æŒä¸­å¿ƒä½ç½® (9å·ç‚¹)
                        const palmCenter = other[9]; 
                        const currentPos = new THREE.Vector2(palmCenter.x, palmCenter.y);

                        if (!isTwoHandRotationActive) {
                            isTwoHandRotationActive = true;
                            lastSecondHandPos.copy(currentPos);
                        } else {
                            // è®¡ç®—ä½ç§»
                            const dx = currentPos.x - lastSecondHandPos.x;
                            const dy = currentPos.y - lastSecondHandPos.y;
                            
                            // åº”ç”¨æ—‹è½¬ (çµæ•åº¦ç³»æ•°)
                            // æ°´å¹³ç§»åŠ¨(dx) -> ç»•Yè½´æ—‹è½¬
                            // å‚ç›´ç§»åŠ¨(dy) -> ç»•Xè½´æ—‹è½¬
                            const rotateSpeed = 4.0;
                            selectedSystem.mesh.rotation.y += dx * rotateSpeed;
                            selectedSystem.mesh.rotation.x += dy * rotateSpeed;

                            lastSecondHandPos.copy(currentPos);
                        }
                    } else {
                        isTwoHandRotationActive = false;
                    }
                } else {
                    isTwoHandRotationActive = false;
                }
            } else {
                pinchSession.active = false;
                pinchSession.handIndex = -1;
            }
        } else {
            pinchSession.active = false;
            pinchSession.handIndex = -1;
        }
        particleSystems.forEach(sys => sys.update());
        renderer.render(scene, camera);
    }

    /**
     * MediaPipe Hands è®¾ç½® (ä»…åœ¨éç§»åŠ¨ç«¯æˆ–æ”¯æŒ getUserMedia æ—¶å°è¯•)
     */
    function isMobileDevice() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
    }

    const isMobile = isMobileDevice();
    const desktopInfo = document.getElementById('desktop-instructions');
    const mobileInfo = document.getElementById('mobile-instructions');

    if (isMobile) {
        desktopInfo.style.display = 'none';
        mobileInfo.style.display = 'block';
        document.getElementById('dpad-container').style.display = 'block';
    }

    // å°è¯•å¯åŠ¨æ‘„åƒå¤´é€»è¾‘
    // å³ä½¿ä¸å¯åŠ¨æ‘„åƒå¤´ï¼Œä¹Ÿéœ€è¦ç¡®ä¿ handLandmarks å·²å®šä¹‰ï¼Œå¦åˆ™ animate ä¸­ä¼šæŠ¥é”™
    let handLandmarks = [];
    
    if (!isMobile && navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        const videoElement = document.getElementsByClassName('input_video')[0];
        
        function onResults(results) {
            if (results.multiHandLandmarks) {
                handLandmarks = results.multiHandLandmarks;
            } else {
                handLandmarks = [];
            }
        }
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        cameraUtils.start().catch((e) => {
            console.log("Camera access denied or not supported:", e);
        });
    }

    init();

    // ç»‘å®šè‡ªåŠ¨ä¿å­˜äº‹ä»¶
    document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'hidden') {
            autoSave();
        }
    });
    
    // å¯åŠ¨æ—¶æ£€æŸ¥è‡ªåŠ¨å­˜æ¡£
    window.addEventListener('load', () => {
        // ç®€å•ç­–ç•¥ï¼šå¦‚æœæœ‰è‡ªåŠ¨å­˜æ¡£ï¼Œç›´æ¥è¯¢é—®æˆ–åŠ è½½
        // è¿™é‡Œæˆ‘ä»¬é€‰æ‹©é™é»˜åŠ è½½ï¼ˆå¦‚æœç”¨æˆ·æ²¡æœ‰æ‰‹åŠ¨æ“ä½œï¼‰ï¼Œæˆ–è€…ä»…æç¤º
        // ä¸ºäº†ä½“éªŒï¼Œæˆ‘ä»¬ç›´æ¥å°è¯•åŠ è½½ï¼Œå¦‚æœå®ƒæ˜¯éç©ºçš„
        // ä½†æ˜¯ä¸ºäº†ä¸è¦†ç›–é»˜è®¤çš„åˆå§‹çŠ¶æ€ï¼ˆå¯èƒ½ç”¨æˆ·æ›´æƒ³çœ‹åˆ°ï¼‰ï¼Œæˆ‘ä»¬å¯ä»¥åšä¸ªåˆ¤æ–­
        // æˆ–è€…ï¼šé»˜è®¤åŠ è½½åˆå§‹çŠ¶æ€ï¼Œç„¶åæ˜¾ç¤º Toast "å‘ç°è‡ªåŠ¨å­˜æ¡£" ?
        // é‰´äºç§»åŠ¨ç«¯åˆ·æ–°å®¹æ˜“ä¸¢æ•°æ®ï¼Œç›´æ¥åŠ è½½æ¯”è¾ƒè´´å¿ƒ
        if (localStorage.getItem(AUTOSAVE_KEY)) {
             loadAutoSave();
        }
    });

</script>
</body>
</html>
